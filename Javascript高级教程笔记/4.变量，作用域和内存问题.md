
#### 传递参数都是按值传递
#### 没有块级作用域，只有全局和局部（function）
#### 垃圾收集
```
a. 引用计数
//按照引用次数来判断
在IE低版本（IE6及以下）会造成内存泄漏问题
//例一
function test(){
        var a={};
        var b={};
        a.prop=b;
        b.prop=a;
}
//例二
//执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收；
window.onload = function(){
    var el = document.getElementById("id");
    el.onclick = function(){
        alert(el.id);
    }
}
b. 标记清除
//退出作用域即标记为不可用，周期清理，如果某个值不需要用了，可以置为null清除引用

```
#### 垃圾回收优化
```
//IE中的问题
在IE6中是按内存分配量来回收的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，但是变量数如果在这些边界值上下浮动时就会频繁触发垃圾回收，造成延时阻塞
IE7开始做了调整，如果触发了回收，且回收比例少于15%，那就触发回收的临界值翻倍，如果大于85%，临界值置回

//回收的影响
//  http://www.cnblogs.com/hyddd/archive/2013/02/07/2908598.html
垃圾回收时会遍历所有变量，会阻塞js进程100ms左右，对于游戏是非常致命的
//1. 分代回收
变量分为持久和临时两个区域，多回收临时区

//2. 增量回收
进行多次回收，每次回收一点点
